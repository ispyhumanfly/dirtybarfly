.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Crypt::SaltedHash 3"
.TH Crypt::SaltedHash 3 "2011-05-27" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::SaltedHash \- Perl interface to functions that assist in working
with salted hashes.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Crypt::SaltedHash;
\&
\&        my $csh = Crypt::SaltedHash\->new(algorithm => \*(AqSHA\-1\*(Aq);
\&        $csh\->add(\*(Aqsecret\*(Aq);
\&
\&        my $salted = $csh\->generate;
\&        my $valid = Crypt::SaltedHash\->validate($salted, \*(Aqsecret\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Crypt::SaltedHash\*(C'\fR module provides an object oriented interface to
create salted (or seeded) hashes of clear text data. The original
formalization of this concept comes from \s-1RFC\-3112\s0 and is extended by the use
of different digital agorithms.
.SH "ABSTRACT"
.IX Header "ABSTRACT"
.SS "Setting the data"
.IX Subsection "Setting the data"
The process starts with 2 elements of data:
.IP "\(bu" 4
a clear text string (this could represent a password for instance).
.IP "\(bu" 4
the salt, a random seed of data. This is the value used to augment a hash in order to
ensure that 2 hashes of identical data yield different output.
.PP
For the purposes of this abstract we will analyze the steps within code that perform the necessary actions
to achieve the endresult hashes. Cryptographers call this hash a digest. We will not however go into an explanation
of a one-way encryption scheme. Readers of this abstract are encouraged to get information on that subject by
their own.
.PP
Theoretically, an implementation of a one-way function as an algorithm takes input, and provides output, that are both
in binary form; realistically though digests are typically encoded and stored in a database or in a flat text or \s-1XML\s0 file.
Take slappasswd5 for instance, it performs the exact functionality described above. We will use it as a black box compiled
piece of code for our analysis.
.PP
In pseudocode we generate a salted hash as follows:
.PP
.Vb 4
\&    Get the source string and salt as separate binary objects
\&    Concatenate the 2 binary values
\&    Hash the concatenation into SaltedPasswordHash
\&    Base64Encode(concat(SaltedPasswordHash, Salt))
.Ve
.PP
We take a clear text string and hash this into a binary object representing the hashed value of the clear text string plus the random salt.
Then we have the Salt value, which are typically 4 bytes of purely random binary data represented as hexadecimal notation (Base16 as 8 bytes).
.PP
Using \s-1SHA\-1\s0 as the hashing algorithm, SaltedPasswordHash is of length 20 (bytes) in raw binary form
(40 bytes if we look at it in hex). Salt is then 4 bytes in raw binary form. The \s-1SHA\-1\s0 algorithm generates
a 160 bit hash string. Consider that 8 bits = 1 byte. So 160 bits = 20 bytes, which is exactly what the
algorithm gives us.
.PP
The Base64 encoding of the binary result looks like:
.PP
.Vb 1
\&    {SSHA}B0O0XSYdsk7g9K229ZEr73Lid7HBD9DX
.Ve
.PP
Take note here that the final output is a 32\-byte string of data. The Base64 encoding process uses bit shifting, masking, and padding as per \s-1RFC\-3548\s0.
.PP
A couple of examples of salted hashes using on the same exact clear-text string:
.PP
.Vb 2
\&    slappasswd \-s testing123
\&    {SSHA}72uhy5xc1AWOLwmNcXALHBSzp8xt4giL
\&
\&    slappasswd \-s testing123
\&    {SSHA}zmIAVaKMmTngrUi4UlS0dzYwVAbfBTl7
\&
\&    slappasswd \-s testing123
\&    {SSHA}Be3F12VVvBf9Sy6MSqpOgAdEj6JCZ+0f
\&
\&    slappasswd \-s testing123
\&    {SSHA}ncHs4XYmQKJqL+VuyNQzQjwRXfvu6noa
.Ve
.PP
4 runs of slappasswd against the same clear text string each yielded unique endresult hashes.
The random salt is generated silently and never made visible.
.SS "Extracting the data"
.IX Subsection "Extracting the data"
One of the keys to note is that the salt is dealt with twice in the process. It is used once for the actual application of randomness to the
given clear text string, and then it is stored within the final output as purely Base64 encoded data. In order to perform an authentication
query for instance, we must break apart the concatenation that was created for storage of the data. We accomplish this by splitting
up the binary data we get after Base64 decoding the stored hash.
.PP
In pseudocode we would perform the extraction and verification operations as such:
.PP
.Vb 8
\&    Strip the hash identifier from the Digest
\&    Base64Decode(Digest, 20)
\&    Split Digest into 2 byte arrays, one for bytes 0 X 20(pwhash), one for bytes 21 X 32 (salt)
\&    Get the target string and salt as separate binary object
\&    Concatenate the 2 binary values
\&    SHA hash the concatenation into targetPasswordHash
\&    Compare targetPasswordHash with pwhash
\&    Return corresponding Boolean value
.Ve
.PP
Our job is to split the original digest up into 2 distinct byte arrays, one of the left 20 (0 \- 20 including the null terminator) bytes and
the other for the rest of the data. The left 0 X 20 bytes will represent the salted  binary value we will use for a byte-by-byte data
match against the new clear text presented for verification. The string presented for verification will have to be salted as well. The rest
of the bytes (21 X 32) represent the random salt which when decoded will show the exact hex characters that make up the once randomly
generated seed.
.PP
We are now ready to verify some data. Let's start with the 4 hashes presented earlier. We will run them through our code to extract the
random salt and then using that verify the clear text string hashed by slappasswd. First, let's do a verification test with an erroneous
password; this should fail the matching test:
.PP
.Vb 6
\&    {SSHA}72uhy5xc1AWOLwmNcXALHBSzp8xt4giL Test123
\&    Hash extracted (in hex): ef6ba1cb9c5cd4058e2f098d71700b1c14b3a7cc
\&    Salt extracted (in hex): 6de2088b
\&    Hash length is: 20 Salt length is: 4
\&    Hash presented in hex: 256bc48def0ce04b0af90dfd2808c42588bf9542
\&    Hashes DON\*(AqT match: Test123
.Ve
.PP
The match failure test was successful as expected. Now let's use known valid data through the same exact code:
.PP
.Vb 6
\&    {SSHA}72uhy5xc1AWOLwmNcXALHBSzp8xt4giL testing123
\&    Hash extracted (in hex): ef6ba1cb9c5cd4058e2f098d71700b1c14b3a7cc
\&    Salt extracted (in hex): 6de2088b
\&    Hash length is: 20 Salt length is: 4
\&    Hash presented in hex: ef6ba1cb9c5cd4058e2f098d71700b1c14b3a7cc
\&    Hashes match: testing123
.Ve
.PP
The process used for salted passwords should now be clear. We see that salting hashed data does indeed add another layer of security to the
clear text one-way hashing process. But we also see that salted hashes should also be protected just as if the data was in clear text form.
Now that we have seen salted hashes actually work you should also realize that in code it is possible to extract salt values and use them
for various purposes. Obviously the usage can be on either side of the colored hat line, but the data is there.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBnew( [%options] )\fR" 4
.IX Item "new( [%options] )"
Returns a new Crypt::SaltedHash object.
Possible keys for \fI\f(CI%options\fI\fR are:
.RS 4
.IP "\(bu" 4
\&\fIalgorithm\fR: It's also possible to use common string representations of the
algorithm (e.g. \*(L"sha256\*(R", \*(L"\s-1SHA\-384\s0\*(R"). If the argument is missing, \s-1SHA\-1\s0 will
be used by default.
.IP "\(bu" 4
\&\fIsalt\fR: You can specify your on salt. You can either specify it as a sequence
of charactres or as a hex encoded string of the form \*(L"HEX{...}\*(R". If the argument is missing,
a random seed is provided for you (recommended).
.IP "\(bu" 4
\&\fIsalt_len\fR:  By default, the module assumes a salt length of 4 bytes (or 8, if it is encoded in hex).
If you choose a different length, you have to tell the \fIvalidate\fR function how long your seed was.
.RE
.RS 4
.RE
.ie n .IP "\fBadd( \fB$data\fB, ... )\fR" 4
.el .IP "\fBadd( \f(CB$data\fB, ... )\fR" 4
.IX Item "add( $data, ... )"
Logically joins the arguments into a single string, and uses it to
update the current digest state. For more details see Digest.
.IP "\fB\f(BIsalt_bin()\fB\fR" 4
.IX Item "salt_bin()"
Returns the salt in binary form.
.IP "\fB\f(BIsalt_hex()\fB\fR" 4
.IX Item "salt_hex()"
Returns the salt in hexadecimal form ('HEX{...}')
.IP "\fB\f(BIgenerate()\fB\fR" 4
.IX Item "generate()"
Generates the seeded hash. Uses the \fIclone\fR\-method of Digest before actually performing
the digest calculation, so adding more cleardata after a call of \fIgenerate\fR to an instance of
\&\fICrypt::SaltedHash\fR has the same effect as adding the data before the call of \fIgenerate\fR.
.ie n .IP "\fBvalidate( \fB$hasheddata\fB, \f(BI$cleardata\fB, [$salt_len] )\fR" 4
.el .IP "\fBvalidate( \f(CB$hasheddata\fB, \f(CB$cleardata\fB, [$salt_len] )\fR" 4
.IX Item "validate( $hasheddata, $cleardata, [$salt_len] )"
Validates a hasheddata previously generated against cleardata. \fI\f(CI$salt_len\fI\fR defaults to 4 if not set.
Returns 1 if the validation is successful, 0 otherwise.
.IP "\fB\f(BIobj()\fB\fR" 4
.IX Item "obj()"
Returns a handle to Digest object.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
\&\fInone yet.\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Digest, MIME::Base64
.SH "AUTHOR"
.IX Header "AUTHOR"
Sascha Kiefer, esskar@cpan.org
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
The author is particularly grateful to Andres Andreu for his article: Salted
hashes demystified \- A Primer (<http://www.securitydocs.com/library/3439>)
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2005 Sascha Kiefer
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
