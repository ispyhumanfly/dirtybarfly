.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Class::Candy 3pm"
.TH DBIx::Class::Candy 3pm "2011-03-09" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Class::Candy \- Sugar for your favorite ORM, DBIx::Class
.SH "VERSION"
.IX Header "VERSION"
version 0.002000
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& package MyApp::Schema::Result::Artist;
\&
\& use DBIx::Class::Candy \-autotable => v1;
\&
\& primary_column id => {
\&   data_type => \*(Aqint\*(Aq,
\&   is_auto_increment => 1,
\& };
\&
\& column name => {
\&   data_type => \*(Aqvarchar\*(Aq,
\&   size => 25,
\&   is_nullable => 1,
\& };
\&
\& has_many albums => \*(AqA::Schema::Result::Album\*(Aq, \*(Aqartist_id\*(Aq;
\&
\& 1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`DBIx::Class::Candy\*(C'\fR is a simple sugar layer for definition of
DBIx::Class results.  Note that it may later be expanded to add sugar
for more \f(CW\*(C`DBIx::Class\*(C'\fR related things.  By default \f(CW\*(C`DBIx::Class::Candy\*(C'\fR:
.IP "\(bu" 4
turns on strict and warnings
.IP "\(bu" 4
sets your parent class
.IP "\(bu" 4
exports a bunch of the package methods that you normally use to define your
DBIx::Class results
.IP "\(bu" 4
makes a few aliases to make some of the original method names a shorter or
more clear
.IP "\(bu" 4
defines very few new subroutines that transform the arguments passed to them
.PP
It assumes a DBIx::Class::Core\-like \s-1API\s0, but you can tailor it to suit
your needs.
.SH "HERE BE DRAGONS"
.IX Header "HERE BE DRAGONS"
Part of the goal of this module is to fix some warts of the original \s-1API\s0
for defining DBIx::Class results.  Given that we would like to get a few
eyeballs on it before we finalize it.  If you are writing code that you will
not touch again for years, do not use this till this warning is removed.
.SH "IMPORT OPTIONS"
.IX Header "IMPORT OPTIONS"
See \*(L"\s-1SETTING\s0 \s-1DEFAULT\s0 \s-1IMPORT\s0 \s-1OPTIONS\s0\*(R" for information on setting these schema wide.
.SS "\-base"
.IX Subsection "-base"
.Vb 1
\& use DBIx::Class::Candy \-base => \*(AqMyApp::Schema::Result\*(Aq;
.Ve
.PP
The first thing you can do to customize your usage of \f(CW\*(C`DBIx::Class::Candy\*(C'\fR
is change the parent class.  Do that by using the \f(CW\*(C`\-base\*(C'\fR import option.
.SS "\-autotable"
.IX Subsection "-autotable"
.Vb 1
\& use DBIx::Class::Candy \-autotable => v1;
.Ve
.PP
Don't waste your precious keystrokes typing \f(CW\*(C`table \*(Aqbuildings\*(Aq\*(C'\fR, let
\&\f(CW\*(C`DBIx::Class::Candy\*(C'\fR do that for you!  See \*(L"\s-1AUTOTABLE\s0 \s-1VERSIONS\s0\*(R" for what the
existing versions will generate for you.
.SS "\-components"
.IX Subsection "-components"
.Vb 1
\& use DBIx::Class::Candy \-components => [\*(AqFilterColumn\*(Aq];
.Ve
.PP
\&\f(CW\*(C`DBIx::Class::Candy\*(C'\fR allows you to set which components you are using at
import time so that the components can define their own sugar to export as
well.  See DBIx::Class::Candy::Exports for details on how that works.
.SS "\-perl5"
.IX Subsection "-perl5"
.Vb 1
\& use DBIx::Class::Candy \-perl5 => v10;
.Ve
.PP
I love the new features in Perl 5.10 and 5.12, so I felt that it would be
nice to remove the boiler plate of doing \f(CW\*(C`use feature \*(Aq:5.10\*(Aq\*(C'\fR and
add it to my sugar importer.  Feel free not to use this.
.SH "IMPORTED SUBROUTINES"
.IX Header "IMPORTED SUBROUTINES"
Most of the imported subroutines are the same as what you get when you use
the normal interface for result definition: they have the same names and take
the same arguments.  In general write the code the way you normally would,
leaving out the \f(CW\*(C`_\|_PACKAGE_\|_\->\*(C'\fR part.  The following are methods that
are exported with the same name and arguments:
.PP
.Vb 10
\& belongs_to
\& has_many
\& has_one
\& inflate_column
\& many_to_many
\& might_have
\& remove_column
\& remove_columns
\& resultset_attributes
\& resultset_class
\& sequence
\& source_name
\& table
.Ve
.PP
There are some exceptions though, which brings us to:
.SH "IMPORTED ALIASES"
.IX Header "IMPORTED ALIASES"
These are merely renamed versions of the functions you know and love.  The idea is
to make your result classes a tiny bit prettier by aliasing some methods.
If you know your \f(CW\*(C`DBIx::Class\*(C'\fR \s-1API\s0 you noticed that in the \*(L"\s-1SYNOPSIS\s0\*(R" I used \f(CW\*(C`column\*(C'\fR
instead of \f(CW\*(C`add_columns\*(C'\fR and \f(CW\*(C`primary_key\*(C'\fR instead of \f(CW\*(C`set_primary_key\*(C'\fR.  The old
versions work, this is just nicer.  A list of aliases are as follows:
.PP
.Vb 4
\& column            => \*(Aqadd_columns\*(Aq,
\& primary_key       => \*(Aqset_primary_key\*(Aq,
\& unique_constraint => \*(Aqadd_unique_constraint\*(Aq,
\& relationship      => \*(Aqadd_relationship\*(Aq,
.Ve
.SH "SETTING DEFAULT IMPORT OPTIONS"
.IX Header "SETTING DEFAULT IMPORT OPTIONS"
Eventually you will get tired of writing the following in every single one of
your results:
.PP
.Vb 4
\& use DBIx::Class::Candy
\&   \-base      => \*(AqMyApp::Schema::Result\*(Aq,
\&   \-perl5     => v12,
\&   \-autotable => v1;
.Ve
.PP
You can set all of these for your whole schema if you define your own \f(CW\*(C`Candy\*(C'\fR
subclass as follows:
.PP
.Vb 1
\& package MyApp::Schema::Candy;
\&
\& use base \*(AqDBIx::Class::Candy\*(Aq;
\&
\& sub base { $_[1] || \*(AqMyApp::Schema::Result\*(Aq }
\& sub perl_version { 12 }
\& sub autotable { 1 }
.Ve
.PP
Note the \f(CW\*(C`$_[1] ||\*(C'\fR in \f(CW\*(C`base\*(C'\fR.  All of these methods are passed the
values passed in from the arguments to the subclass, so you can either throw
them away, honor them, die on usage, or whatever.  To be clear, if you define
your subclass, and someone uses it as follows:
.PP
.Vb 1
\& use MyApp::Schema::Candy \-base => \*(AqMoose\*(Aq, \-perl5 => v30, \-autotable => v3;
.Ve
.PP
Your \f(CW\*(C`base\*(C'\fR method will get \f(CW\*(C`Moose\*(C'\fR, your
\&\f(CW\*(C`perl_version\*(C'\fR will get \f(CW30\fR, and your \f(CW\*(C`autotable\*(C'\fR will get
\&\f(CW3\fR.
.SH "SECONDARY API"
.IX Header "SECONDARY API"
.SS "has_column"
.IX Subsection "has_column"
There is currently a single \*(L"transformer\*(R" for \f(CW\*(C`add_columns\*(C'\fR, so that
people used to the Moose api will feel more at home.  Note that this \fBmay\fR
go into a \*(L"Candy Component\*(R" at some point.
.PP
Example usage:
.PP
.Vb 5
\& has_column foo => (
\&   data_type => \*(Aqvarchar\*(Aq,
\&   size => 25,
\&   is_nullable => 1,
\& );
.Ve
.SS "primary_column"
.IX Subsection "primary_column"
Another handy little feature that allows you to define a column and set it as
the primary key in a single call:
.PP
.Vb 4
\& primary_column id => {
\&   data_type => \*(Aqint\*(Aq,
\&   is_auto_increment => 1,
\& };
.Ve
.SS "unique_column"
.IX Subsection "unique_column"
This allows you to define a column and set it as unique in a single call:
.PP
.Vb 4
\& unique_column name => {
\&   data_type => \*(Aqvarchar\*(Aq,
\&   size => 30,
\& };
.Ve
.SH "AUTOTABLE VERSIONS"
.IX Header "AUTOTABLE VERSIONS"
Currently there is a single version, \f(CW\*(C`v1\*(C'\fR, which looks at your class name,
grabs everything after \f(CW\*(C`::Schema::Result::\*(C'\fR, removes the \f(CW\*(C`::\*(C'\fR's, converts it
to underscores instead of camel-case, and pluralizes it.  Here are some
examples if that's not clear:
.PP
.Vb 3
\& MyApp::Schema::Result::Cat \-> cats
\& MyApp::Schema::Result::Software::Buidling \-> software_buildings
\& MyApp::Schema::Result::LonelyPerson \-> lonely_people
.Ve
.PP
Also, if you just want to be different, you can easily set up your own naming
scheme.  Just add a \f(CW\*(C`gen_table\*(C'\fR method to your candy subclass.  The method
gets passed the class name and the autotable version, which of course you may
ignore.  For example, one might just do the following:
.PP
.Vb 2
\& sub gen_table {
\&   my ($self, $class) = @_;
\&
\&   $class =~ s/::/_/g;
\&   lc $class;
\& }
.Ve
.PP
Which would tranform \f(CW\*(C`MyApp::Schema::Result::Foo\*(C'\fR into
\&\f(CW\*(C`myapp_schema_result_foo\*(C'\fR.
.PP
Or maybe instead of using the standard \f(CW\*(C`MyApp::Schema::Result\*(C'\fR namespace you
decided to be different and do \f(CW\*(C`MyApp::DB::Table\*(C'\fR or something silly like that.
You could pre-process your class name so that the default \f(CW\*(C`gen_table\*(C'\fR will
still work:
.PP
.Vb 3
\& sub gen_table {
\&   my $self = shift;
\&   my $class = $_[0];
\&
\&   $class =~ s/::DB::Table::/::Schema::Result::/;
\&   return $self\->next::method(@_);
\& }
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Arthur Axel \*(L"fREW\*(R" Schmidt <frioux+cpan@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is copyright (c) 2011 by Arthur Axel \*(L"fREW\*(R" Schmidt.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
